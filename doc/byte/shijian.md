在校外实践的过程中，主要参与了关于推荐系统架构中特征生产平台化的工作。
    首先推荐系统包含复杂且多个环节，从一些离线的计数任务、数据库中获取原始的数据，再进一步倒排、正排、消重服务等生成候选集合，再由召回服务从候选集合中召回用户可能感兴趣的候选项，在进一步精排，根据模型打分最终取排名靠前的投放给用户。通过这样一系列复杂的流程从数千万的候选集中选出用户可能喜欢以及具有差异化的投放集，最后还要根据用户对当前投放集作出的反应，再进一步反馈和修正模型的打分系统以及各个环节的策略，来帮助模型系统更加准确的进行推荐，无论是视频、文章、广告都是如此。
    在这个整个链路过程中，数据的流动模型其实就是以候选的属性为原始信息为基础，进而生成特征再处理为模型需要的数据集。而最开始的特征生产平台环节就是为了将原始的数据先一步做处理和配置，生成后续想要的特征集，根据不同的特征集去生成特征然后训练模型、开启实验查看当前模型的效果、稳定性以及特征的信息。特征是什么？比如，一个视频的特征又视频id、视频分类、视频的点赞数、收藏数、转发数、评论数、时长、发布人等等一系列属性组成了这个视频的特征组，而这些特征组在进行特征计算的时候并不是以字符串的形式存储，而是以embedding的向量方式进行存储。特征平台化从多个数据接入层对数据源进行配置过滤，组成特征配置项写入在线数据源，一般数据接入层主要是从HDFS、kafka、tbase等，从繁杂的数据源写入线上数据源，供上游服务进行消费。

​	在实践过程中，平台化的工作量主要集中在对相关接口的封装、对中间变量的保存、页面的显示以及如何以最优的方式提供傻瓜化的操作，因为特征生产以来多个底层服务并向上游服务提供，这就需要我们在其他底层服务提供的接口上开发。一个产品的研发其实最重要的是如何让用户以最简单、最易用的方式可以方便的使用平台完成他本身复杂的任务，但是这类平台本身就必须对用户的使用门槛有一定的高度，他需要明白一些平台操作对应的底层原理、需要懂得自己的每一步操作到底是干了什么，这往往是比代码的编写要难的多，需要对用户进行文档说明、操作引导、名词解释等等一系列工作。

​	在平台的技术组成主要是以python的flask框架为主，主要存储关于平台自身管理员、用户信息、配置信息等中间层信息，最后调用其他OpenAPI或者调用其他下游服务来完成平台后台的总体工作。平台前端主要是以React框架为主体的SPA应用，使用公司内部自研的脚手架工具帮助我们去管理、打包、依赖加载、热更新整个前端项目。在开发平台的过程中，还了解到产品的上线中间的过程是如此复杂，环境也是斑驳复杂，有本地环境、预发布环境、还有和线上同数据但是又与线上环境相隔离的环境、甚至机房集群环境、国内外环境，就好比国外环境可能也分好多个，这么多的环境也对平台的开发过程、前后端联调过程带来了巨大的挑战。

​	最后，我重点描述下基础特征计算，

- 基础特征：

  - 无状态特征：经过简单的 ETL ( extract - transform - load ) 就能获取的特征，不需要暂存临时状态。

  - 有状态特征：带有窗口的复杂特征，要实现状态存储层，存储中间态的数据从而实现窗口特征的聚合操作。比如统计五分钟、半小时内视频的点击量。

- 数据源：Kafka、BMQ 、Hive、HDFS、Abase、RPC

- 计算引擎：Spark、Flink

- 计算内容：业务方自定义，例如 filter，joiner，窗口统计等操作

- 结果写入：Kafka、BMQ、Abase、Tbase、RPC

### **特征生产现状与开发动机**

- 缺乏统一的基础特征生产平台。统一的平台可以对特征进行统一管理，如监控管理、流量控制。此外，业务方仅需考虑数据的生产，不需要考虑如何写入在线服务，减少业务的维护成本。

- 特征服务出现新需求：支持各种粒度的带窗口特征、TOPK计算等。

## **框架设计**

### **功能概述**

- 提供基础特征的计算和在线服务
  - 计算类型：batch、stream 

- 特征类型：有状态特征、无状态特征

- 提供更加抽象的基础特征业务层DSL (domain specific language)

- 基于 FlinkSQL 和 FlinkState 支持复杂的窗口计算

### **基础特征的生产周期**

| 特征定义层 | DSL定义特征是什么，包括数据源、过滤规则、特征值类型、计算接口等。 |
| ---------- | ------------------------------------------------------------ |
| 特征抽取层 | 把DSL定义的规则转化为FlinkSQL、SparkSQL去执行，把原始数据转化为结构化的通用数据结构 FeatureRaw。对于有状态特征，再把 FeatureRaw 转化为通用数据结构 FeatureInfo（带有时间戳）。 |
| 状态存储层 | 存储 FeatureInfo。用 Flink State 存储；或者中心化的存储，例如 Tbase、Abase。 |
| 特征计算层 | 基于 FeatureRaw 或 FeatureInfo 做特征计算，对常用的特征计算提供通用的实现。 |
| 触发层     | 决定特征计算层的算子被触发的时间。                           |
| 特征存储层 | 根据DSL定义把计算得到的特征存储到下游。                      |